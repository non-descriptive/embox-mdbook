<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Embox Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ru/embox_quick_overview_ru.html"><strong aria-hidden="true">1.</strong> Обзор</a></li><li><a href="ru/embox_quick_start_ru.html"><strong aria-hidden="true">2.</strong> Быстрый старт</a></li><li><a href="ru/embox_user_manual_ru.html"><strong aria-hidden="true">3.</strong> Руководство пользователя</a></li><li><a href="ru/embox_modular_structure_ru.html"><strong aria-hidden="true">4.</strong> Модульная структура Embox</a></li><li><a href="ru/build/embox_build_ru.html"><strong aria-hidden="true">5.</strong> Сборка</a></li><li><ol class="section"><li><a href="ru/build/embox_execute_debug_ru.html"><strong aria-hidden="true">5.1.</strong> Запуск и отладка</a></li></ol></li><li><a href="ru/embox_example_list.html"><strong aria-hidden="true">6.</strong> Примеры</a></li><li><ol class="section"><li><a href="ru/example/hello_world.html"><strong aria-hidden="true">6.1.</strong> Hello, world!</a></li><li><a href="ru/example/blinking_led.html"><strong aria-hidden="true">6.2.</strong> Мигаем LED-светодиодом</a></li><li><a href="ru/example/driver.html"><strong aria-hidden="true">6.3.</strong> Пример добавления драйвера</a></li><li><a href="ru/example/external_app.html"><strong aria-hidden="true">6.4.</strong> Пример внешнего приложения</a></li></ol></li><li><a href="ru/drivers/embox_drivers_ru.html"><strong aria-hidden="true">7.</strong> Драйверы</a></li><li><a href="ru/embox_platform_list.html"><strong aria-hidden="true">8.</strong> Поддерживаемые платформы</a></li><li><ol class="section"><li><a href="ru/platform/embox_supported_platforms_arm_ru.html"><strong aria-hidden="true">8.1.</strong> ARM</a></li><li><a href="ru/platform/embox_supported_platforms_qemu_ru.html"><strong aria-hidden="true">8.2.</strong> QEMU</a></li><li><a href="ru/platform/embox_supported_platforms_ru.html"><strong aria-hidden="true">8.3.</strong> RU</a></li><li><a href="ru/platform/embox_supported_platforms_x86_ru.html"><strong aria-hidden="true">8.4.</strong> x86</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Embox Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#Краткое-описание" id="Краткое-описание"><h1>Краткое описание</h1></a>
<ul>
<li>
<p><strong><em>Embox</em></strong> — операционная система реального времени, ориентированная на применение во встроенных системах.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> — кросс-платформенная ОС. Архитектурно-зависимые части вынесены в отдельные модули, что упрощает процесс портирования на новые платформы. Embox поддерживает следующие процессорные архитектуры: <strong><em>x86, ARM, MIPS, SPARC, PPC,  Microblaze, E2k</em></strong>.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> является многозадачной ОС и поддерживает различные уровни приоритета задач, вытесняющую многозадачность, защиту от инверсии приоритета и различные способы синхронизации.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> предоставляет слой <strong><em>POSIX</em></strong>-совместимости, который позволяет использовать большое количество готового ПО разработанного под <strong><em>Linux</em></strong>. Примерами являются библиотека <strong><em>Qt</em></strong>, клиент и сервер SSH — <strong><em>Dropbear</em></strong>, проект по созданию SIP-телефонов на основе популярной библиотеки <strong><em>PJSIP</em></strong>.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> позволяет сохранить разработку привычной и удобной на всех платформах, в том числе на платформах с ограниченными ресурсами, такими как микроконтроллеры, так как используются стандартные средства разработки для <strong><em>Linux</em></strong>, а библиотека языка С входит в состав проекта.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> имеет низкие требования к ресурсам, поскольку построен на принципах модульности и конфигурируемости. При конфигурации системы можно выбрать, какие модули будут включены в образ. Таким образом, достигается создание образа, нацеленного на конкретную задачу, будь то система для тестирования аппаратного обеспечения, или полноценная система с множеством приложений и богатой функциональностью.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> позволяет создавать более безопасные системы. Основным вариантом использования является статическая конфигурация системы, при которой гарантируется, что невозможно выполнить приложения не включенные в конечный образ.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> хорошо подходит для устройств интернета вещей (<strong><em>IoT</em></strong>). Поскольку имеет развитый сетевой стек и богатый набор прикладных приложений и библиотек, но вместе с тем имеет низкие требования к аппаратным ресурсам.</p>
</li>
<li>
<p><strong><em>Embox</em></strong> хорошо подходит для робототехники, поскольку позволяет совмещать в одной системе, задачи требующие сложные функциональные возможности и задачи “реального времени”.</p>
</li>
</ul>
<a class="header" href="#Быстрый-старт" id="Быстрый-старт"><h1>Быстрый старт</h1></a>
<p>Ознакомление с Embox лучше начать с запуска на эмуляторе <strong><em>qemu</em></strong> поддерживающего различные процессорные архитектуры.</p>
<a class="header" href="#Получение-кода-embox" id="Получение-кода-embox"><h2>Получение кода Embox</h2></a>
<p>Клонируем мастер:</p>
<pre><code>    $ git clone https://github.com/embox/embox
</code></pre>
<p>Либо скачиваем архивом из <a href="https://github.com/embox/embox/releases">https://github.com/embox/embox/releases</a></p>
<a class="header" href="#Работа-в-windows--и-macos" id="Работа-в-windows--и-macos"><h2>Работа в Windows  и MacOS</h2></a>
<p>Все описания сделаны для Linux. Для сборки и работы под Windows и MacOS лучше использовать Docker в котором уже настроено все необходимое окружение для начальной работы.
Для этого:</p>
<ul>
<li>Установите docker для вашей ОС.</li>
<li>Убедитесь, что docker установлен правильно с помощью команд:</li>
</ul>
<pre><code>        $ docker-machine ls
        $ docker-machine start default
</code></pre>
<ul>
<li>Перейдите в консоли в корневую папку с исходниками Embox.</li>
<li>Запустите докер выполнив скрипт</li>
</ul>
<pre><code>        $ ./scripts/docker/docker_start.sh
</code></pre>
<ul>
<li>Для упрощения работы выполните скрипт командой</li>
</ul>
<pre><code>        $. ./scripts/docker/docker_rc.sh
</code></pre>
<p>Данный скрипт позволит писать команду <code>dr</code> вместо <code>docker run</code></p>
<p>Далее перед каждой командой необходимо вставлять <code>dr</code>. Например,</p>
<pre><code>    $ dr make confload-x86/qemu
    $ dr make
    $ dr ./scripts/qemu/auto_qemu
</code></pre>
<p>Для конфигурации сборки и запуска базового темплейта.</p>
<p>После установки и проверки работоспособности, можно пропустить раздел настройка окружения и перейти сразу к разделу “Сборка и запуск на QEMU”</p>
<a class="header" href="#Настройка-окружения" id="Настройка-окружения"><h2>Настройка окружения</h2></a>
<p>Необходимые пакеты: make, gcc (кросс-компилятор под выбранную архитектуру,  см. “Установка кросс-компилятора”).
Дополнительные пакеты (рекомендуется установить сразу): build-essential gcc-multilib curl libmpc-dev python
Пример установки для Debian:</p>
<pre><code>    $ sudo apt-get install make gcc \
        build-essential gcc-multilib \
        curl libmpc-dev python
</code></pre>
<p>Пример установка для Arch:</p>
<pre><code>    $ sudo pacman -S make gcc-multilib cpio qemu
</code></pre>
<a class="header" href="#Установка-кросс-компилятора" id="Установка-кросс-компилятора"><h2>Установка кросс-компилятора</h2></a>
<a class="header" href="#x86" id="x86"><h3>x86:</h3></a>
<pre><code>     $ sudo apt-get install gcc
</code></pre>
<p>Обычно уже установленный пакет. Вам потребуется другой компилятор, если Вы настраиваете окружение самостоятельно для Windows или MacOS.</p>
<a class="header" href="#arm" id="arm"><h3>ARM:</h3></a>
<pre><code>     $ sudo apt install arm-none-eabi-gcc
</code></pre>
<p>Или для Debian</p>
<pre><code>    $ sudo apt install gcc-arm-none-eabi
</code></pre>
<p>Либо скачать архив с тулчейном с сайта <a href="https://launchpad.net/gcc-arm-embedded">https://launchpad.net/gcc-arm-embedded</a>. Распаковать архив и сделать export тулчейна:</p>
<pre><code>   $ export PATH=$PATH:&lt;путь к тулчейну&gt;/gcc-arm-none-eabi-&lt;version&gt;/bin
</code></pre>
<a class="header" href="#sparc-microblaze-mips-powerpc-msp430" id="sparc-microblaze-mips-powerpc-msp430"><h3>SPARC, Microblaze, MIPS, PowerPC, MSP430:</h3></a>
<p>Для этих архитектур можно воспользоваться нашим проектом по сборке crosstool <a href="https://github.com/embox/crosstool">https://github.com/embox/crosstool</a>.</p>
<p>Можно скачать последнюю версию уже собранного архива в требуемым кросс-компилятором отсюда <a href="https://github.com/embox/crosstool/releases">https://github.com/embox/crosstool/releases</a>.</p>
<p>Или собрать его выкачав скрипты из репозитория с помощью команды</p>
<pre><code>    $ ./crosstool.sh ARCH
</code></pre>
<p>После этого должен появиться архив с тулчейном — ARCH-elf-toolchain.tar.bz2. Далее, его нужно распаковать и добавить в переменную окружения PATH как показано выше для ARM.</p>
<a class="header" href="#Установка-эмулятора-qemu" id="Установка-эмулятора-qemu"><h2>Установка эмулятора QEMU</h2></a>
<p>Поддерживаемые архитектуры: x86, ARM, MIPS, Sparc, PPC, Microblaze.</p>
<p>Необходимые пакеты: qemu (под выбранную архитектуру)</p>
<pre><code>    $ sudo apt-get install qemu-system-&lt;ARCH&gt; 
</code></pre>
<p>где <ARCH> это i386, arm, sparc, mips, ppc или misc (для microblaze)
Примечание: Все пакеты qemu можно установить единым пакетом —</p>
<pre><code>    $ sudo apt-get install qemu-system
</code></pre>
<a class="header" href="#Сборка-и-запуск-на-qemu" id="Сборка-и-запуск-на-qemu"><h2>Сборка и запуск на QEMU</h2></a>
<p>Загружаем конфигурацию по умолчанию для выбранной архитектуры:</p>
<pre><code>   $ make confload-&lt;ARCH&gt;/qemu
</code></pre>
<p>, где <ARCH>: x86, arm, mips, ppc, sparc, microblaze.
Пример под x86:</p>
<pre><code>    $ make confload-x86/qemu
</code></pre>
<p>Собираем Embox:</p>
<pre><code>    $ make
</code></pre>
<p>или запускаем параллельную сборку:</p>
<pre><code>    $ make (-jN)
</code></pre>
<p>Пример:</p>
<pre><code>    $ make -j4
</code></pre>
<p>Запускаем:</p>
<pre><code>    $ ./scripts/qemu/auto_qemu
</code></pre>
<p>Пример вывода в консоль:</p>
<pre><code>Embox kernel start
    unit: initializing embox.kernel.task.task_resource: done
    unit: initializing embox.mem.vmem_alloc: done
    ...
</code></pre>
<p>Если все unit тесты прошли успешно и система загружена, появиться консоль в которой можно выполнять команды. Начать можно с команды <strong><em>'help'</em></strong> которая выведет список доступных команд для вашей конфигурации.
Для выхода из эмулятора qemu нажмите последовательно <strong><em>ctrl+’A’</em></strong> затем <strong><em>‘x’</em></strong>.</p>
<a class="header" href="#Особенности-системы-сборки-mybuild" id="Особенности-системы-сборки-mybuild"><h2>Особенности системы сборки Mybuild</h2></a>
<p><strong><em>Embox</em></strong> - модульная и конфигурируемая система. Для этих целей был разработан декларативный язык описания <strong><em>Mybuild</em></strong>. Он позволяет описывать как отдельные единицы системы (модули) так и всю систему в целом.</p>
<p><strong><em>Модуль</em></strong> является базовым понятием для системы сборки. Он содержит: список файлов относящихся к данному модулю, параметры которые можно задать модулю в момент конфигурации и список зависимостей.</p>
<p><strong><em>Конфигурация</em></strong> является детализированным описанием желаемой системы. Включает в себя: список модулей необходимых для сборки, параметры модулей и описания правил сборки (компилятор, флаги компилятора, карта памяти устройства, и так далее). На основе конфигурации и описания модулей строится граф с параметрами системы и по нему генерируются различные файлы для сборки: линкер скрипты, makefile-ы, заголовочные файлы. В конфигурации не обязательно указывать все необходимые модули, они подтягиваются по зависимостям из описания модулей.</p>
<p>Текущая конфигурация располагается в папке <strong><em>conf/</em></strong>. Может быть выбрана с помощью команды</p>
<pre><code>    $ make confload-&lt;CONF_NAME&gt;
</code></pre>
<p>Например, для задания демонстрационной конфигурации для запуска на <strong><em>qemu-system-arm</em></strong> необходимо выполнить</p>
<pre><code>    $ make confload-arm/qemu
</code></pre>
<p>Для просмотра готовых конфигураций можно выполнить</p>
<pre><code>    $ make confload
</code></pre>
<p>После задания текущей конфигурации можно изменять файлы под свои требования. Например, чтобы добавить какое нибудь приложение которого нет в текущей конфигурации достаточно добавить в файл <strong><em>conf/mods.conf</em></strong> строку</p>
<pre><code>    include &lt;PACKAGE_NAME&gt;&lt;MODULE_NAME&gt;
</code></pre>
<p>Пример, для добавления в конфигурацию команды <strong><em>'help'</em></strong> нужно добавить строчку</p>
<pre><code>    include embox.cmd.help
</code></pre>
<a class="header" href="#Создание-и-запуск-hello-world" id="Создание-и-запуск-hello-world"><h2>Создание и запуск “hello world”</h2></a>
<p>Приложение в Embox представляет собой модуль в описании которого содержаться атрибуты указывающие, что это приложение можно запускать из командной строки. Исходный код представляет собой обычное приложение которое можно скомпилировать с том числе и в Linux окружении.</p>
<a class="header" href="#Создание-и-запуск-примера" id="Создание-и-запуск-примера"><h3>Создание и запуск примера</h3></a>
<p>Разберем простейшее приложение <strong><em>“hello world”</em></strong>.</p>
<ul>
<li>Создадим папку <strong><em>hello_world</em></strong> в <strong><em>src/cmds</em></strong>:</li>
</ul>
<pre><code class="language-shell">    $ mkdir src/cmds/hello_world
</code></pre>
<ul>
<li>Создадим файл с исходным кодом приложения <strong><em>src/cmds/hello_world/hello_world.c</em></strong> со следующим содержанием:</li>
</ul>
<pre><code class="language-c">        #include &lt;stdio.h&gt;

        int main(int argc, char **argv) {
            printf(&quot;Hello, world!\n&quot;);
        }
</code></pre>
<ul>
<li>Создадим файл описания модуля <strong><em>src/cmds/hello_world/Mybuild</em></strong> следующего содержания:</li>
</ul>
<pre><code class="language-java">        package embox.cmd

        @AutoCmd
        @Cmd(name = &quot;hello_world&quot;, help=”First Embox application”)
        module hello_world {
            source &quot;hello_world.c&quot;
        }
</code></pre>
<ul>
<li>Добавим в файл конфигурации системы conf/mods.conf строчку с подключением нового модуля:</li>
</ul>
<pre><code>        include embox.cmd.hello_world
</code></pre>
<ul>
<li>Компилируем:</li>
</ul>
<pre><code class="language-shell">        $ make
</code></pre>
<ul>
<li>Запускаем:</li>
</ul>
<pre><code class="language-shell">        $ ./scripts/qemu/auto_qemu
</code></pre>
<p>В появившейся консоли убедимся, что если набрать команду <strong><em>'help'</em></strong> то в списке будет новая команда. Выполним команду набрав ее в консоли <strong><em>hello_world</em></strong>
Должно появиться наше сообщение выведенное с помощью функции <strong><em>printf()</em></strong> :</p>
<pre><code class="language-shell">        root@embox:/#hello_world 
        Hello, world!
        root@embox:/#
</code></pre>
<a class="header" href="#Файл-описания-модуля" id="Файл-описания-модуля"><h3>Файл описания модуля</h3></a>
<p>Разберем немного подробнее файл описания модуля.</p>
<pre><code class="language-java">        package embox.cmd

        @AutoCmd
        @Cmd(name = &quot;hello_world&quot;, help=”First Embox application”)
        module hello_world {
            source &quot;hello_world.c&quot;
        }
</code></pre>
<p>В первой строке идет указание имени пакета <strong><em>package embox.cmd</em></strong>. В Embox все модули распределены по пакетам, для удобства именования. Полное имя модуля будет состоять из имени пакета и имени модуля. Имя модуля в нашем случае находиться в строке <strong><em>module hello_world</em></strong>.</p>
<p>Строка <strong><em>source &quot;hello_world.c&quot;</em></strong> указывает файлы с исходным кодом необходимые для корректной сборки модуля.</p>
<p>В строке <strong><em>@Cmd(name = &quot;hello_world&quot;, help=”First Embox application”)</em></strong> задается атрибут для модуля. Во первых модуль будет представлять из себя приложение, во вторых задает имя с помощью которого это приложение можно вызвать. И наконец, задается строка, которая будет отображаться для этого приложения при вызове команды <strong><em>'help'</em></strong>. Строка @AutoCmd указывает, что в приложении есть стандартная функция входа в приложение <strong><em>main()</em></strong>, которая будет заменена на другой символ в процессе сборки.</p>
<a class="header" href="#Система-сборки-mybuild" id="Система-сборки-mybuild"><h1>Система сборки Mybuild</h1></a>
<p>Mybuild - это система автоматизации сборки и конфигурирования для модульных приложений.</p>
<p>Mybuild реализован поверх <a href="http://www.gnu.org/software/make/">GNU Make</a>, тем самым поддерживая все возможности инкрементальной и параллельной сборки последнего. Кроме того, это позволяет встроить Mybuild в уже существующую инфраструктуру сборки, использующую Make.
В то же время, несмотря на использование Make, Mybuild использует собственный синтаксис, лишенный недостатков языка Makefile'ов.</p>
<a class="header" href="#Процесс-разработки" id="Процесс-разработки"><h2>Процесс разработки</h2></a>
<p>Типичный сценарий разработки проекта, использующего Mybuild, включает две группы людей:</p>
<table><thead><tr><th>            Разработчики                                 </th><th>    Пользователи                      </th></tr></thead><tbody>
<tr><td> которые поддерживают файлы для сборки разрабатываемых ими компонентов.</td><td>  которым требуется просто собрать проект (возможно, в различных конфигурациях). </td></tr>
</tbody></table>
<p><em>В действительности, есть еще разработчики самого Mybuild, но их мы пока что не рассматриваем.</em>
Таким образом, существует два типа файлов для сборки: My-файлы и Config-файлы</p>
<a class="header" href="#my-файлы" id="my-файлы"><h3>My-файлы</h3></a>
<p>My-файлы используются для описания всех модулей приложения, доступных для сборки, их отношения между собой, а также параметры конфигурации.
Эти файлы пишутся разработчиками самого приложения и обычно располагаются в дереве файлов с исходным кодом.</p>
<pre><code>module HelloWorld {
   source &quot;hello.c&quot;
}
</code></pre>
<p>My-файлы именуются <em><code>Mybuild</code></em> либо <em><code>*.my</code></em>.</p>
<a class="header" href="#config-файлы" id="config-файлы"><h3>Config-файлы</h3></a>
<p>Config-файлы содержат указания для сборки определенных модулей и конкретные значения параметров конфигурации.
Предполагается, что данные файлы составляются пользователями, тем не менее, разработчики могут предоставить шаблоны для типичных конфигураций.</p>
<pre><code>configuration Main {
    include HelloWorld
}
</code></pre>
<p>Конфигурационные файлы имеют расширение <em><code>.config</code></em>.</p>
<p>Оба типа файлов являются обычными текстовыми файлами (не XML!), которые можно редактировать в любом текстовом редакторе.</p>
<p>После того как необходимые my- и config-файлы готовы, проект можно собрать командой <code>make</code>.
На основе предоставленных сборочных файлов Mybuild решит, что именно и в каком порядке необходимо собрать.</p>
<p>В заключение, процесс сборки можно представить следующим образом:
<img src="images/mybuild/mybuild-workflow.png" alt="" /></p>
<a class="header" href="#mybuild-процесс-сборки" id="mybuild-процесс-сборки"><h2>Mybuild процесс сборки</h2></a>
<p>Процесс сборки с помощью системы Mybuild можно представить следующим образом:
<img src="images/mybuild/mybuild-build_sequence.png" alt="" /></p>
<a class="header" href="#Подготовка-скриптов" id="Подготовка-скриптов"><h3>Подготовка скриптов</h3></a>
<p>Mybuild написана на расширении языка Make, поэтому, сначала требуется преобразовать код написанный на расширении языка Make в классические Make-файлы. Для ускорения этой процедуры используется кэширование: преобразуются только измененные с предыдущего запуска файлы.</p>
<p>На этом этапе происходит проверка актуальности кэша исходных файлов Mybuild и библиотеки расширения. Если файл с исходным кодом не изменялся, используется его закэшированная версия. Иначе файл загружается, преобразуется и кэшируется с помощью скрипта.</p>
<a class="header" href="#Создание-графа-описания-модулей" id="Создание-графа-описания-модулей"><h3>Создание графа описания модулей</h3></a>
<p>Обработка Mybuild файлов (файлов описание модулей) разбивается на фазы:
<img src="images/mybuild/mybuild-graph_creation.png" alt="" /></p>
<ul>
<li>Нахождение Myfile в дереве с исходным кодом.</li>
<li>Для каждого файла:
<ul>
<li>Чтение файла.</li>
<li>Синтаксический разбор, создание объекта (mk/mybuild/myfile-model.mk) на каждую разобранную синтаксическую конструкцию.</li>
<li>Сохранение полученной после разбора модели файла для использования последующими стадиями (путь по умолчанию: mk/.cache/mybuild/files/).</li>
</ul>
</li>
<li>Создание набора моделей, представляющего полное описание графа модулей, разрешение ссылок между моделями в наборе.</li>
<li>Проведение различных проверок, относящихся к графу модулей (соответствие типов опций и инициализирующих их значений, циклическое наследование, и т.д)</li>
<li>Кэширование полученного набора моделей.</li>
</ul>
<a class="header" href="#Создание-модели-системы" id="Создание-модели-системы"><h3>Создание модели системы</h3></a>
<p>Для описания модели системы так же используется специализированный язык описания. Поэтому, для обработки файлов конфигурации проводятся фазы, аналогичные фазам 1-5 обработки файлов описания модулей. Затем, происходит создание Build-модели (mk/mybuild/build-model.mk), в нее входит модули, их файлы, опции модулей, опции компиляции. Для этого используются модели конфигурации и Mybuild.</p>
<p><img src="images/mybuild/mybuild-model_creation.png" alt="" /></p>
<a class="header" href="#Генерация-необходимых-ресурсов" id="Генерация-необходимых-ресурсов"><h3>Генерация необходимых ресурсов</h3></a>
<p>На этом этапе проводится сборка полученной на предыдущем этапе Build-модели.</p>
<ul>
<li>Генерируется исходник на языке Си, содержащий run-time представление Build-модели.</li>
<li>Для модулей генерируются заголовочные файлы с опциями и экспортированными из модуля заголовочными файлами.</li>
<li>Для файлов с исходным кодом генерируются командные файлы, содержащие параметры командной строки компилятора.</li>
<li>Генерируется Make-правила для сборки целевого образа и промежуточных объектных файлов.</li>
</ul>
<a class="header" href="#Запуск-скриптов-на-исполнение" id="Запуск-скриптов-на-исполнение"><h3>Запуск скриптов на исполнение</h3></a>
<p>На этой стадии сборки происходит передача управления от Mybuild к сгенерированному им скриптам сборки Make. Результатом выполнения данного этапа является полностью собранный образ целевой системы.</p>
<a class="header" href="#mybuild---внутренняя-структура" id="mybuild---внутренняя-структура"><h2>Mybuild - внутренняя структура</h2></a>
<p>Система сборки целиком написана на языке GNU Make и состоит из набора скриптов. Следует различать три основных типа Makefile’ов, используемых для реализации:</p>
<ul>
<li>Классические Makefile’ы, в которых задаются правила для выполнения тех или иных целей, их зависимости и т.д. В основном к ним относятся скрипты верхнего уровня, определяющие последовательность запуска остальных скриптов.</li>
<li>Библиотеки функций, в которых определяются функции и классы. Большая часть логики Mybuild реализована именно в таких скриптах. Основная часть кода (за исключением сравнительно небольшого блока раскрутки), написана с использованием расширенного синтаксиса языка Make.</li>
<li>Скрипты, результатом выполнения которых является текстовый файл.</li>
</ul>
<a class="header" href="#Классические-makefileы" id="Классические-makefileы"><h3>Классические Makefile’ы</h3></a>
<p>Для выполнения любой внешней цели (которую вызывает пользователь) сперва читается корневой Makefile. Его можно рассматривать как обертку для запуска самой системы сборки. В этом скрипте происходит проверка версии Make и необходимых флагов, задаются значения по умолчанию для директорий сборки и т.д. Далее управление передается в mk/main.mk.
mk/main.mk</p>
<p>Этот скрипт - фасад системы. В нем определяются все доступные для выполнения цели, а также документация для этих целей, которую можно увидеть, выполнив “make help” или “make help-'&lt;'goal'&gt;'”. Можно различать два вида целей:
Цели, которые можно выполнить “на месте” (загрузка конфигурации, clean, вывод справки по целям и т.п.).
Цели, для выполнения которых требуется чтение всех my-файлов и построения модели сборки (собственно, сборка проекта). В этом случае управление передается специальному загрузочному скрипту mk/load.mk
mk/load.mk</p>
<p>Скрипт используется для раскрутки остальных скриптов системы сборки, загрузки my-файлов и создания модели сборки. Разделен на два файла:</p>
<ul>
<li>load-mk.inc.mk, который занимается раскруткой скриптов (библиотеки функций),</li>
<li>load-mybuild.inc.mk, который вызывает скрипты для разбора my-файлов, их линковки, сериализации и построения модели сборки.</li>
</ul>
<p><img src="images/mybuild/mybuild_classic_makefile.png" alt="" /></p>
<a class="header" href="#Модульная-структура-embox" id="Модульная-структура-embox"><h1>Модульная структура Embox</h1></a>
<p>Важными особенностями Embox является модульность и конфигурируемость. Под модульностью подразумевается разбиение проекта на небольшие логические части - модули, а под конфигурируемостью - возможность детального задания характеристик конечной системы, на основе списка требуемых модулей и параметров используемых модулей. Для этого используется система сборки Mybuild, со специальным языком программирования (DSL) позволяющим описывать как модули так и систему в целом. При этом программная логика модулей располагается отдельно от описания и разрабатывается на обычном языке программирования (GPL).</p>
<a class="header" href="#Файлы-описания-модулей" id="Файлы-описания-модулей"><h2>Файлы описания модулей</h2></a>
<a class="header" href="#Пакеты-модулей" id="Пакеты-модулей"><h3>Пакеты модулей</h3></a>
<p>Структурно модули организованы в иерархические группы (пространства имен), составленные по функциональной принадлежности. Данный механизм позволяет избежать коллизий в именах модулей, сохраняя их короткими.
Как правило, имя пакета совпадает в путем в файловой системе, что облегчает поиск файлов модуля в дереве исходного кода.</p>
<p>Пример задания имени пакета:</p>
<pre><code class="language-java">package embox.arch
</code></pre>
<a class="header" href="#Интерфейсы-и-абстрактные-модули" id="Интерфейсы-и-абстрактные-модули"><h3>Интерфейсы и абстрактные модули</h3></a>
<p>Интерфейсы для модулей являются прямым аналогом интерфейсов и абстрактных классов в объектно-ориентированном программировании.
Язык описания модулей поддерживает наследование, таким образом, позволяя ввести понятие и интерфейсов (модулей без реализации) и абстрактных модулей (с частичной реализацией). Модули, которые реализуют один интерфейс или наследуют общий родительский модуль, взаимозаменяемы до тех пор, пока это не изменяет функциональность системы. Данный подход позволяет пользователю выбирать среди модулей, реализующих один интерфейс, но имеющих разные алгоритмы, чтобы обеспечить необходимые свойства системы. Для указания того что модуль является наследуемым нужно использовать ключевое слово <strong><em>abstract</em></strong>.</p>
<p>Пример задания абстрактного модуля:</p>
<pre><code class="language-java">package embox.arch

//...

abstract module interrupt { }
//...
</code></pre>
<p>Для указания наследования используется ключевое слово <strong><em>extends</em></strong>.</p>
<p>Пример наследования от абстрактного модуля:</p>
<pre><code class="language-java">    module interrupt_stub extends embox.arch.interrupt {
    //...
    }
</code></pre>
<a class="header" href="#Атрибуты-модулей" id="Атрибуты-модулей"><h3>Атрибуты модулей</h3></a>
<p>Описание каждого модуля состоит из нескольких возможных атрибутов: файлы исходного кода, опции и зависимости.</p>
<a class="header" href="#Файлы-исходного-кода" id="Файлы-исходного-кода"><h4>Файлы исходного кода</h4></a>
<p>Каждый модуль может указывать список файлов, которые необходимо скомпилировать и включить в итоговый образ в случае включения данного модуля в сборку.
Список файлов указывается в атрибуте source модуля.
Помимо “обычных” файлов на языке Си или ассемблера, можно также добавлять заголовочные файлы и дополнительные линкер-скрипты. Тип файлов различается по расширению:</p>
<ul>
<li>.c/.S - исходные коды на языке Си или ассемблера. При сборке компилируются и включаются в итоговый образ системы. Во время компиляции есть возможность получить значения опций модуля, к которому относятся эти файлы исходного кода.</li>
<li>.h - заголовочные файлы, содержащие объявления и определения, необходимые для реализации модулем какого-либо интерфейса. При сборке для каждого включенного модуля генерируется специальный заголовочный файл, включающий все перечисленные .h-файлы данного модуля, а также модулей, расширяющих данный. Это позволяет использовать различные реализации того или иного интерфейса без изменения исходного кода модулей, которые его используют. Такой способ абстракции необходим, поскольку различные реализации могут определять ту или иную структуру по разному, в то время как структура может использоваться другими модулями без знания деталей реализации. То же самое относится и к макросам, inline-функциям и константам.</li>
<li>.lds.S - линкер-скрипты, позволяющие влиять на процесс компоновки модулей в итоговый образ. Типичное использование таких скриптов - это добавление новых секций.</li>
</ul>
<p>Пример задания заголовочного файла с реализацией абстрактного модуля:</p>
<pre><code class="language-java">    module interrupt_stub extends embox.arch.interrupt {
        source &quot;interrupt_stub.h&quot;
}
</code></pre>
<p>Пример задания файла с линкер скриптом и файла с исходным кодом:</p>
<pre><code class="language-java">    module static_heap extends heap_place {
        // ...
        source &quot;heap.lds.S&quot;
        source &quot;static_heap.c&quot;
        // ...
    }
</code></pre>
<a class="header" href="#Опции" id="Опции"><h4>Опции</h4></a>
<p>Опции позволяют определить на этапе конфигурирования числовые, логические или строковые параметры, которые могут влиять способ сборки, инициализацию или работу модуля. Опции также могут иметь или не иметь значение по умолчанию. В последнем случае значение должно быть указано во время конфигурирования, в первом - это не обязательно, тогда будет использоваться значение по умолчанию.
Опции разделяются на три типа в зависимости от типа задаваемого значения. Тип опции задается после ключевого слова option перед именем опции:</p>
<ul>
<li>string - строковые опции</li>
<li>number - целочисленные данные</li>
<li>boolean - булевое значение - true или false</li>
</ul>
<p>Чтобы получить значение опции при компиляции исходного кода используются специальные макросы:</p>
<ul>
<li>OPTION_STRING_GET - для получения значения строковых опций</li>
<li>OPTION_NUMBER_GET - для числовых опций</li>
<li>OPTION_BOOLEAN_GET - для булевых опций</li>
</ul>
<p>Аргументом макроса выступает имя опции, определенное в my-файле.</p>
<a class="header" href="#Зависимости" id="Зависимости"><h4>Зависимости</h4></a>
<p>Зависимости являются способом указать системе сборки, что корректное функционирование данного модуля невозможно без некоторых других модулей. Список зависимостей может включать интерфейсы, при этом это означает, что в сборку должен быть включен ровно один модуль, реализующий требуемый интерфейс.
Межмодульные зависимости указываются через атрибут depends. В значении атрибута можно перечислять как модули, так и интерфейсы. Система сборки гарантирует, что при включении данного модуля, будут добавлены и все его зависимости. В случае зависимости от интерфейса используется одна из его реализаций.
Знание о межмодульных зависимостях используется как для получения списка модулей для сборки, так и в момент загрузки системы (см. далее). В некоторых случаях требуется просто включить нужный модуль вместе с данным, без изменения порядка загрузки, например, для использования таких глобальных модулей (аспектов), как поддержка многопроцессорности, логгирование или отладочные утверждения (assert). Поскольку у таких модулей нет как такового состояния (загружен или не загружен), для указания их в качестве зависимости атрибут depends дополняется аннотацией @NoRuntime. В этом случае зависимость будет использоваться во время сборки, но не будет определять порядок загрузки модулей относительно друг друга.</p>
<a class="header" href="#Аннотации" id="Аннотации"><h3>Аннотации</h3></a>
<p>Аннотации применяются для модификации семантики некоторых элементов описания. Это позволяет дополнять язык описаний без изменения грамматики, что делает язык более гибким.</p>
<p>Пример задания с помощью аннотации реализации абстрактного модуля по умолчанию:</p>
<pre><code class="language-java">    @DefaultImpl(embox.arch.generic.interrupt_stub)
    abstract module interrupt { }
</code></pre>
<a class="header" href="#Описание-конфигурации" id="Описание-конфигурации"><h2>Описание конфигурации</h2></a>
<p>Описание модулей необходимо для создания целевого образа. При конфигурировании система сборки позволяет объединить отдельные модули системы (модули ядра, драйвера, тесты, приложения), задать параметры для отдельных модулей и указать дополнительные параметры для создания образа под различные аппаратные платформы.</p>
<a class="header" href="#Структура-конфигурации" id="Структура-конфигурации"><h3>Структура конфигурации</h3></a>
<p>Конфигурация образа происходит редактированием файлов конфигурации в каталоге conf/. Его содержимое следующее:</p>
<ul>
<li>lds.conf - Файл lds.conf содержит определение карты памяти, использующейся на конкретной аппаратной платформе.</li>
<li>mods.config - Файл mods.config содержит названия и опции модулей, которые будут включены в образ ОС. Также, для каждого из перечисленного в этом файле модуля возможно указать новые значения опций.</li>
<li>rootfs/ - Директория rootfs содержит файлы, которые будут включены в состав файловой системы, которая будет доступна на ранних этапах загрузки.</li>
</ul>
<a class="header" href="#Процесс-конфигурирования" id="Процесс-конфигурирования"><h3>Процесс конфигурирования</h3></a>
<p>Использование модуля в образе ОС подразумевает его включение в конфигурацию ОС.</p>
<a class="header" href="#Базовая-конфигурация" id="Базовая-конфигурация"><h4>Базовая конфигурация</h4></a>
<p>Подготовка конфигурации является длительным процессом, поэтому, чтобы сократить время, затрачиваемое на конфигурирование, используются базовые конфигурации. Их назначение заключается в том, чтобы предоставить пользователю основу с некоторыми базовыми функциями, которую тот сможет модифицировать под свои нужды.</p>
<p>В состав ОС включены несколько конфигураций, предназначенных для использования как базовых. Для каждой платформы подготовлено несколько конфигураций, обладающих разными свойствами и возможностями.</p>
<p>Чтобы получить подготовленную конфигурацию, для, например, самой основной поддержки платформы x86, воспользуйтесь следующей командой:</p>
<pre><code>make confload-x86/qemu
</code></pre>
<p>Эта команда загружает в каталог conf подготовленную базовую конфигурацию под названием qemu для платформы x86. Список всех базовых конфигураций можно увидеть и выбрать среди них, набрав:</p>
<pre><code>make confload
</code></pre>
<a class="header" href="#Включение-модуля-в-конфигурацию" id="Включение-модуля-в-конфигурацию"><h4>Включение модуля в конфигурацию</h4></a>
<p>Список модулей для включения в конфигурацию находится в файле conf/mods.config, который имеет следующую структуру:</p>
<pre><code>package genconfig

configuration conf {
    [список_модулей]
}
</code></pre>
<p>[список_модулей] определяет положение набора строк, каждая из которых определяет включение модуля. Добавьте новую строку к списку модулей следющего содержания:</p>
<pre><code>    include pkg.new_package.empty
</code></pre>
<p>В итоге, файл conf/mods.config должен иметь следующее содержание:</p>
<pre><code>package genconfig

configuration conf {
    [список_модулей]
include pkg.new_package.empty
}
</code></pre>
<p>После этого, модуль empty из пакета pkg.new_package будет включен сборку.
Чтобы проверить непротиворечивость полученной сборки и, в случае успеха, произвести создание образа ОС, наберите</p>
<pre><code>    make
</code></pre>
<p>В случае положительного результата будет выведено сообщение “Build complete”. Убедиться в том, что ОС содержит новый модуль можно запустив ОС на исполнение и выполнить команду lsmod c параметрами -n и empty, которая выведет список модулей, у которых в имени модуля присутствует подстрока “empty”.</p>
<pre><code>lsmod -n empty
</code></pre>
<p>Результатом lsmod будет являться печать</p>
<pre><code>    *  pkg.new_package.empty
</code></pre>
<p>Это означает, что модуль pkg.new_package.empty имеется в системе, а символ “*” обозначает, что в данный момент модуль загружен и работает.</p>
<a class="header" href="#Сборка" id="Сборка"><h1>Сборка</h1></a>
<a class="header" href="#Описание-конфигурации-проекта" id="Описание-конфигурации-проекта"><h2>Описание конфигурации проекта</h2></a>
<p>Описание конфигурация представляет собой детальное задание требований к функциональности системы. Подробнее смотри раздел &quot;Модульная структура Embox&quot;. Текущая конфигурация содержится в файлах расположенных папке 'conf/'.</p>
<a class="header" href="#Выбор-конфигурации" id="Выбор-конфигурации"><h2>Выбор конфигурации</h2></a>
<p>Для задания желаемых свойств целевой системы необходимо создать описание в папке 'conf/'. Если существует описание конфигурации с близкими свойствами проще воспользоваться ими. И на основе уже существующей конфигурации создать свою.</p>
<p>Посмотреть существующие конфигурации можно с помощью команды:</p>
<pre><code>    $ make confload
</code></pre>
<p>затем можно сделать выбранную конфигурацию рабочей с помощью команды:</p>
<pre><code>    $ make confload-&lt;template&gt;
</code></pre>
<p>Пример:</p>
<pre><code>    $ make confload
    List of available templates:
      ...
      platform/quake3/qemu
      ...
    Use 'make confload-&lt;template&gt;' to load one.

    $ make confload-platform/quake3/qemu
</code></pre>
<p>в нем выбирается имеющаяся в списке конфигурация platform/quake3/qemu</p>
<a class="header" href="#Сборка-из-имеющейся-конфигурации" id="Сборка-из-имеющейся-конфигурации"><h2>Сборка из имеющейся конфигурации</h2></a>
<p>Для сборки образа из имеющейся конфигурации необходимо сделать рабочей выбранную конфигурацию, как описано в предыдущем примере. А затем выполнить команду</p>
<pre><code>    $ make
</code></pre>
<p>для сборки образа. В случае успешного завершения появится надпись &quot;Build complete&quot;, а также файл образа в формате ELF 'build/base/bin/embox'.</p>
<p>Например:</p>
<pre><code>    text	   data	    bss	    dec	    hex	filename
    1259425	 248540	170593504	172101469	a420f5d	build/base/bin/embox
    Build complete
</code></pre>
<a class="header" href="#Изменение-характеристик-системы" id="Изменение-характеристик-системы"><h2>Изменение характеристик системы</h2></a>
<p>После выбора конфигурации ее требуется изменить. Текущая (рабочая) конфигурация находиться в папке conf/. Изменения файлов в этой папке изменяют характеристики конечной системы до желаемых. Важно: если сделать make confload-<template>, удалить папку или сделать очистку проекта, которая затронет текущую конфигурацию (например, make distclean), текущие изменения потеряются.</p>
<a class="header" href="#Изменение-функциональности-системы" id="Изменение-функциональности-системы"><h3>Изменение функциональности системы</h3></a>
<a class="header" href="#Изменение-списка-модулей" id="Изменение-списка-модулей"><h4>Изменение списка модулей</h4></a>
<p>Функциональность системы описывается в файле mods.conf. Для изменения нужно изменить данный файл. Например, для включения дополнительной команды в список нужно добавить строчку</p>
<pre><code>    include &lt;PACKAGE_NAME&gt;.&lt;MODULE_NAME&gt;
</code></pre>
<p>Например</p>
<pre><code>    include embox.cmds.help
</code></pre>
<p>то же самое для обычных модулей.</p>
<a class="header" href="#Изменение-параметров-модулей" id="Изменение-параметров-модулей"><h4>Изменение параметров модулей</h4></a>
<p>Для изменения параметров модуля нужно указать в скобках имя опции и желаемое значение. Например, для установки размера стека потока нужно изменить (или установить) параметр thread_stack_size в модуле embox.kernel.thread.core:</p>
<pre><code>    include embox.kernel.thread.core(thread_stack_size=0x4000)
</code></pre>
<a class="header" href="#Порядок-загрузки" id="Порядок-загрузки"><h4>Порядок загрузки</h4></a>
<p>В конфигурации можно также повлиять на порядок загрузки модулей системы, для этого используется аттрибут @Runlevel(level) например @Runlevel(2), но обычно этого не требуется, поскольку при загрузке модулей учитываются их зависимости, и если требуется подгрузить модуль для работы данного модуля, то он подгрузится по зависимостям.</p>
<a class="header" href="#Изменение-реализации-интерфейса" id="Изменение-реализации-интерфейса"><h4>Изменение реализации интерфейса</h4></a>
<p>Для изменения реализации интерфейса или абстрактного модуля, что это такое см. раздел &quot;Модульная структура Embox&quot;, нужно просто подключить другой модуль реализующий данный интерфейс.</p>
<p>Например, абстрактный модуль heap_api</p>
<pre><code>    @DefaultImpl(heap_bm)
    abstract module heap_api {
        ...
    }
</code></pre>
<p>Для подключения модуля heap_simple который также реализует данный интерфейс</p>
<pre><code>    module heap_simple extends heap_api {module heap_simple extends heap_api {
    ...
    }
</code></pre>
<p>необходимо удалить (если есть) модуль heap_bm то есть следующую строчку</p>
<pre><code>    include embox.mem.heap_bm
</code></pre>
<p>и все остальные модули которые наследуют данный абстрактный модуль
и добавить</p>
<pre><code>    include embox.mem.heap_simple
</code></pre>
<a class="header" href="#Изменение-флагов-компиляции-отладка-оптимизации" id="Изменение-флагов-компиляции-отладка-оптимизации"><h3>Изменение флагов компиляции (отладка, оптимизации)</h3></a>
<p>Некоторыми флагами компиляции можно управлять. Флаги компиляции задаются в файле build.conf текущей конфигурации.
Например, флаг, который часто требует изменения, флаг оптимизации:</p>
<pre><code>    CFLAGS += -O0
</code></pre>
<p>данную строчку нужно заменить на</p>
<pre><code>    CFLAGS += -O2
</code></pre>
<p>для сборки с оптимизацией O2.</p>
<p>Также важным флагом является флаг -g линкера, который добавляет секцию с отладочной информацией в образ системы:</p>
<pre><code>    LDFLAGS += -N -g
</code></pre>
<p>его также можно удалить для уменьшения размера, но тогда отладка будет не доступна.</p>
<a class="header" href="#Очистка-проекта" id="Очистка-проекта"><h2>Очистка проекта</h2></a>
<p>Сборка Embox происходит в несколько этапов. Можно выделить следующие большие этапы:</p>
<ul>
<li>Задание текущей конфигурации</li>
<li>Создание графа модулей и генерация на их основе артефактов для сборки</li>
<li>Сборка</li>
</ul>
<p>Поэтому очистка тоже может &quot;очищать&quot; (приводить в состояние) проект до разных стадий сборки. Для этого используются три цели make:</p>
<ul>
<li>make distclean</li>
<li>make cacheclean</li>
<li>make clean</li>
</ul>
<p>Цель clean просто удаляет папку build c собранными объектными и бинарными файлами. Для большинства случаем этого достаточно.</p>
<p>Цель cacheclean полностью выполняет цель clean (то есть удаляет папку build), но кроме этого удаляет папку <code>mk/.cache</code>, в которой содержатся артефакты от разбора mybuild файлов (файлов описания модулей).</p>
<p>Цель distclean полностью приводит проект в первоначальное состояние. То есть удаляет рабочую конфигурацию, чистит все сгенерированные и скомпилированные файлы.</p>
<a class="header" href="#Полезные-команды" id="Полезные-команды"><h2>Полезные команды</h2></a>
<a class="header" href="#Справка-по-командам-сборки" id="Справка-по-командам-сборки"><h3>Справка по командам сборки</h3></a>
<p>Больше информации о возможностях командной строки при сборке можно получить с помощью make цели help:</p>
<pre><code>    $ make help
</code></pre>
<p>есть различные подразделы цели, например с помощью:</p>
<pre><code>    $ make help-mod
</code></pre>
<p>выводится справка по управлению модулями в текущей конфигурации</p>
<pre><code>Usage: make mod-&lt;INFO&gt;

  Print &lt;INFO&gt; info about modules:
  list: list all modules included in build
  brief-&lt;module_name&gt;: show brief informataion about module: dependencies, options,
    source files
  include-reason-&lt;module_name&gt;: show dependence subtree desribing why &lt;module_name&gt;
    was included in build
</code></pre>
<a class="header" href="#Получение-дизассемблера-текущего-образа" id="Получение-дизассемблера-текущего-образа"><h3>Получение дизассемблера текущего образа</h3></a>
<p>Файл с дизассебмлером можно получить с помощью команды:</p>
<pre><code>    $ make disasm
</code></pre>
<a class="header" href="#Получение-графа-модулей" id="Получение-графа-модулей"><h3>Получение графа модулей</h3></a>
<p>Граф модулей в формате png:</p>
<pre><code>    $ make dot
</code></pre>
<p>появиться файл build/doc/embox.png.</p>
<p>Вам потребуется установить пакет graphviz</p>
<pre><code>   $ sudo apt install graphviz
</code></pre>
<a class="header" href="#Получение-документации-из-комментариев-в-doxygen-формате" id="Получение-документации-из-комментариев-в-doxygen-формате"><h3>Получение документации из комментариев в doxygen формате</h3></a>
<p>Для генерации документации по API из комментариев в doxygen формате можно воспользоваться командой</p>
<pre><code>    $ make docsgen
</code></pre>
<p>появиться папка build/docs/html в которой в формате html находится сгенеренная документация</p>
<p>Вам потребуется пакет doxygen</p>
<pre><code>   $ sudo apt install doxygen
</code></pre>
<a class="header" href="#Управление-модулями" id="Управление-модулями"><h3>Управление модулями</h3></a>
<p>Для получения списка всех модулей которые включены в текущую конфигурацию нужно выполнить команду:</p>
<pre><code>   $ make mod-list
</code></pre>
<p>Можно получить более подробную информацию по каждому модулю, например, список модулей включает embox.net.route</p>
<pre><code>    ...
    embox.net.route
    ...
</code></pre>
<p>получить по нему информацию можно с помощью команды</p>
<pre><code>    $ make mod-brief-embox.net.route
</code></pre>
<p>в результате появится информация о модуле</p>
<pre><code>    --- embox.net.route ---
    Inclusion reason: as dependence
    Depends:
    embox.net.core
        embox.mem.pool_ndebug
        embox.util.DListDebug
    Dependents:
        embox.cmd.net.ping
        embox.cmd.net.route
        embox.net.af_inet
        embox.net.ipv4
        embox.net.tcp_sock
    OptInsts:
        route_table_size : 8
    Sources:
     src/net/l3/route.c
</code></pre>
<p>в которой можно узнать файлы которые включены в модуль, опции уже с установленными значениями, причину по которой включен модуль (напрямую из конфига или подтянулся по зависимостям) и зависимости самого модуля.</p>
<p>Порой нужно понять почему подключается тот или иной модуль. Для этого можно воспользоваться командой:</p>
<pre><code>    make include-reason-&lt;module_name&gt;
</code></pre>
<p>Например, для того же модуля embox.net.route:</p>
<pre><code>    $ make mod-include-reason-embox.net.route
    embox.net.route: as dependence:
        embox.cmd.net.ping: explicit
        embox.cmd.net.route: explicit
        embox.net.af_inet: explicit
        embox.net.ipv4: explicit
        embox.net.tcp_sock: explicit
    #
</code></pre>
<a class="header" href="#Запуск" id="Запуск"><h1>Запуск</h1></a>
<a class="header" href="#Загрузка-на-qemu" id="Загрузка-на-qemu"><h2>Загрузка на QEMU</h2></a>
<p>Собранный образ можно запустить QEMU. Самый простой способ - выполнить скрипт ./scripts/qemu/auto_qemu:</p>
<pre><code>$ sudo ./scripts/qemu/auto_qemu
</code></pre>
<p>Этот скрипт создает tuntab, для чего ему нужны права суперпользователя. Кроме того, в скрипте используется утилита ethtool. Установка для основанных на Debian систем:</p>
<pre><code>$ sudo apt-get install ethtool
</code></pre>
<p>Если запуск прошел успешно, то на экране QEMU будут выводиться сообщения. После загрузки системы появится приглашение &quot;embox&gt;&quot;, теперь можно запускать команды на выполнение. Например, &quot;help&quot; выведет список доступных команд.</p>
<p>Для проверки соединения можно пропинговать интерфейс 10.0.2.16. Если соединение установлено, к терминалу можно подключиться по telnet.</p>
<p>Для выхода из Qemu нужно набрать последовательность ctrl + 'a', затем 'X'.</p>
<a class="header" href="#Отладка" id="Отладка"><h1>Отладка</h1></a>
<p>Для работы в режиме отладки можно использовать тот же скрипт, передав ему в качестве параметров флаги -s -S -no-kvm, то есть:</p>
<pre><code>$ sudo ./scripts/qemu/auto_qemu -s -S -no-kvm
</code></pre>
<p>После этого QEMU будет ожидать подключения gdb-клиентом.</p>
<p>Для отладки с помощью консольного отладчика В другом терминале нужно запустить gdb:</p>
<pre><code>$ gdb ./build/base/bin/embox
...
(gdb) target extended-remote :1234
(gdb) continue
</code></pre>
<p>Cистема начнет загрузку.</p>
<p>В любой момент в терминале gdb можно нажать ctrl + 'c', посмотреть стек текущего потока (backtrace), установить точки останова (break &lt;имя функции&gt;, break &lt;имя файла&gt;:&lt;номер строки&gt;).</p>
<a class="header" href="#Примеры" id="Примеры"><h1>Примеры</h1></a>
<ul>
<li><a href="ru/example/hello_world.html">Hello, world!</a></li>
<li><a href="ru/example/blinking_led.html">Мигаем LED-светодиодом</a></li>
<li><a href="ru/example/driver.html">Пример добавления драйвера</a></li>
<li><a href="ru/example/external_app.html">Пример внешнего приложения</a></li>
</ul>
<a class="header" href="#Пример-hello-world" id="Пример-hello-world"><h1>Пример “Hello World”</h1></a>
<p>Для добавления обычного примера команды выводящей сообщение “hello world” необходимо создать файл “hello.c” с исходным кодом на языке Си.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    printf(&quot;Hello World!\n&quot;);
    return 0;
}
</code></pre>
<p>И затем добавить описание модуля.</p>
<a class="header" href="#Добавление-модуля" id="Добавление-модуля"><h2>Добавление модуля</h2></a>
<p>Все модули и интерфейсы системы описываются в my-файлах: файлах с расширением .my или имеющих имя Mybuild (без расширения).
Структурно каждый my-файл содержит объявление пакета, которому принадлежат все определяемые в файле сущности, (опционально) список импортируемых имен из других пакетов, а также определения самих модулей и интерфейсов.
К примеру, для добавления новой команды для встроенного в ядро командного интерпретатора создадим новый файл Hello.my со следующим содержимым:</p>
<pre><code class="language-java">package embox.cmd.tutorial

@AutoCmd
@Cmd(name=&quot;hello&quot;, help=&quot;Prints ‘Hello World’ string&quot;)
module hello {
    source &quot;hello.c&quot;
}
</code></pre>
<p>В этом примере описывается простой модуль имеющий всего один атрибут (source) - файл с исходным кодом “hello.c”, которых будет скомпилирован и связан с ядром в случае добавления модуля в сборку.
Аннотация @Cmd регистрирует модуль в системе как команду встроенного интерпретатора, позволяя, таким образом, запускать ее по имени “hello”. Необязательный параметр help содержит строку, которая будет выведана при запуске команды “help hello” (если модуль help также включен в сборку). Аннотация @AutoCmd позволяет использовать привычную функцию main() в качестве точки входа в программу.</p>
<a class="header" href="#Атрибуты-модуля" id="Атрибуты-модуля"><h3>Атрибуты модуля</h3></a>
<p>Модуль hello достаточно примитивен и не определяет никаких внешних зависимостей или опций. Единственный его атрибут - source - определяет набор исходных файлов для компиляции.
Опции
Теперь модифицируем пример таким образом, чтобы строка приветствия задавалась в виде опции. Для этого используется атрибут option.
Добавим модулю hello (файл Hello.my) строковую опцию greeting:</p>
<pre><code class="language-c">// ...
module hello {
    // ...
    option string greeting = &quot;World&quot;
}
</code></pre>
<p>И модифицируем файл исходного кода hello.c таким образом, чтобы команда после слова “Hello” выводила строку, содержащуюся в значении опции greeting:</p>
<pre><code class="language-c">#define GREETING OPTION_STRING_GET(greeting)

// ...
    printf(&quot;Hello %s!\n&quot;, GREETING);
// ...
</code></pre>
<a class="header" href="#Включение-в-сборку" id="Включение-в-сборку"><h2>Включение в сборку</h2></a>
<p>Для того, чтобы новый модуль оказался в результирующем образе ядра, его необходимо добавить в конфигурацию сборки, которая описывается в файле conf/mods.config:</p>
<pre><code>package genconfig

configuration conf {
    // ...
    include embox.cmd.tutorial.hello
}
</code></pre>
<p>Для того, чтобы переопределить значение опции, в конфигурации следует задать новые значения для опций в скобках после указания модуля:</p>
<pre><code>// ...
    include embox.cmd.tutorial.hello(greeting=&quot;Everyone&quot;)
// ...
</code></pre>
<p>Как и многие атрибуты модуля, конфигурация также поддерживает добавление аннотаций. Наиболее часто используемой является аннотрация @Runlevel, позволяющая разбить загрузку системы на стадии и определить, на каком этапе загружать тот или иной модуль.</p>
<p>Как правило, на ранних стадиях (runlevel=0) загружаются драйверы устройств, необходимых для корректного функционирования системы (например, контроллер прерываний), основные компоненты системы, а также исполняются низкоуровневые тесты и процедуры самодиагностики. Следует отметить, что runlevel определяет лишь максимальную стадию, на которой должен быть запущен данный модуль. Таким образом, если какой-либо модуль, загружаемый на нулевой стадии, зависит от модуля, загружаемого позже, последний все-равно будет загружен раньше, т.е. на нулевой стадии.</p>
<a class="header" href="#Пример-blinking-led" id="Пример-blinking-led"><h1>Пример “Blinking led”</h1></a>
<a class="header" href="#Библиотека-libgpio" id="Библиотека-libgpio"><h2>Библиотека libgpio</h2></a>
<p>В Embox интерфейс GPIO предоставляется библиотекой libgpio. Для использование библиотеки в команде необходимо подключить заголовочный файл <code>&lt;drivers/gpio/gpio.h&gt;</code>.</p>
<p>Библиотека имеет следующий интерфейс:</p>
<ul>
<li>
<p><code>int gpio_setup_mode(unsigned short port, gpio_mask_t pins, int mode)</code> - функция задания режима работы вывода. Режим может быть одним из следующих:</p>
<p>Некоторые базовые режимы (см. <code>&lt;drivers/gpio/gpio.h&gt;</code>):</p>
<ul>
<li><code>GPIO_MODE_OUTPUT</code> - режим вывода</li>
<li><code>GPIO_MODE_INPUT</code> - режим ввода</li>
<li><code>GPIO_MODE_INT_MODE_RISING</code> - режим прерывания</li>
<li><code>GPIO_MODE_ALTERNATE</code> - режим Alternate. При этом номер функции может быть выставлен с помощью <code>GPIO_ALTERNATE(num)</code>. То есть, в итоге режим будет вида <code>GPIO_MODE_ALTERNATE | GPIO_ALTERNATE(num)</code>.</li>
</ul>
</li>
<li>
<p><code>void gpio_set(unsigned short port, gpio_mask_t pins, char level)</code> - установить значение на выходе. Режим вывода должен быть <code>GPIO_MODE_OUTPUT</code>.</p>
</li>
<li>
<p><code>void gpio_toggle(unsigned short port, gpio_mask_t pins)</code> - инвертировать значение на выходе. Режим вывода должен быть GPIO_MODE_OUTPUT.</p>
</li>
<li>
<p><code>gpio_mask_t gpio_get(unsigned short port, gpio_mask_t pins)</code> - получить значение на входе. Результат представляется в виде маски. Режим вывода должен быть GPIO_MODE_INPUT.</p>
</li>
<li>
<p><code>int gpio_irq_attach(unsigned short port, gpio_mask_t pins, irq_handler_t pin_handler, void *data)</code> - задание обработчика прерывания. Режим вывода должен быть <code>GPIO_MODE_INT_MODE_RISING</code>.</p>
</li>
</ul>
<a class="header" href="#Простое-мигание-диодом" id="Простое-мигание-диодом"><h2>Простое мигание диодом</h2></a>
<p>Данный пример демонстрирует исходный код простейшего приложения которое в цикле мигает светодиодом для платы STM32F4discovery. В данном разделе разбирается только исходный код на языке Си. Как добавить описание модуля и включить приложение в текущую конфигурацию описано в разделе &quot;Пример “Hello World”&quot;</p>
<p>Светодиод подключен к выводу 12 порта D в примере используются именно эти значения для простоты и понятности. Номера портов могут быть переданы как через аргументы командной строки, так и через опции модуля ( см. раздел &quot;Опции модуля&quot;), либо заданы для конкретной платы самостоятельно.</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

#include &lt;drivers/gpio/gpio.h&gt;

#define LED4_PIN        (1 &lt;&lt; 12)

int main(int argc, char *argv[]) {
    int cnt;

    gpio_setup_mode(GPIO_PORT_D, LED4_PIN, GPIO_MODE_OUTPUT);
    gpio_set(GPIO_PORT_D, LED4_PIN, 0);

    for(cnt = 0; cnt &lt; 100; cnt++) {
        sleep(1);
        gpio_toggle(GPIO_PORT_D, LED4_PIN);
    }

    return 0;
}

</code></pre>
<p>Перед использованием вывод нужно проинициализировать, задать режим выхода, с помощью функции <code>gpio_setup_mode()</code>. Затем устанстанавливается начальное значение 0.
Далее идет цикл до 100 переключений, в котором происходит задержка на 1 секунду и инвертируется значение на выходе.</p>
<a class="header" href="#Переключение-светодиода-как-реакция-на-нажатие-кнопки" id="Переключение-светодиода-как-реакция-на-нажатие-кнопки"><h2>Переключение светодиода как реакция на нажатие кнопки</h2></a>
<p>Данный пример демонстрирует исходный код приложения которое переключает состояние сведодиода по нажатию кнопки для платы STM32F4discovery.</p>
<p>Как и в случае с предыдущим примером состояние выводов определено схематикой, задано константами прямо в коде и может быть изменено описанными способами.</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;kernel/irq.h&gt;
#include &lt;drivers/gpio/gpio.h&gt;

#define LED4_PIN        (1 &lt;&lt; 12)
#define USER_BUTTON_PIN (1 &lt;&lt; 0)

irq_return_t user_button_hnd(unsigned int irq_nr, void *data) {
    gpio_toggle(GPIO_PORT_D, LED4_PIN);
    return IRQ_HANDLED;
}

int main(int argc, char *argv[]) {
    gpio_setup_mode(GPIO_PORT_D, LED4_PIN, GPIO_MODE_OUTPUT);
    gpio_setup_mode(GPIO_PORT_A, USER_BUTTON_PIN,
        GPIO_MODE_INT_MODE_RISING);

    gpio_set(GPIO_PORT_D, LED4_PIN, 0);

    if (0 &gt; gpio_irq_attach(GPIO_PORT_A, USER_BUTTON_PIN,
            user_button_hnd, NULL)) {
        return -1;
    }

    sleep(30);

    return 0;
}

</code></pre>
<p>Отличие от примера с простым миганием светодиодом заключается в использовании еще одного вывода, который переключен в режим прерывания с помощью функции <code>gpio_setup_mode()</code>. А с помощью функции <code>gpio_irq_attach()</code> на событие по изменению состояния на выводе подключенном к кнопке, повешен обработчик. В обработчике происходит инвертирование значения на выходе светодиода.</p>
<a class="header" href="#Пример-добавления-драйвера" id="Пример-добавления-драйвера"><h1>Пример добавления драйвера</h1></a>
<a class="header" href="#Пример-стороннего-приложения" id="Пример-стороннего-приложения"><h1>Пример стороннего приложения</h1></a>
<p>Данный пример демонстрирует как подключить к сборке сторонний проект с открытым кодом.</p>
<p>Для примера разберем добавление редактора 'nano'</p>
<p>Как и в случае с другими приложениями, необходимо добавить описание модуля</p>
<pre><code>    package third_party.cmd

    @App
    @AutoCmd
    @Build(stage=2,script=&quot;$(EXTERNAL_MAKE)&quot;)
    @Cmd(name = &quot;nano&quot;,
        help = &quot;Text editor&quot;,
        man = '''
            NAME
                nano - Nano's ANOther editor
            SYNOPSIS
                nano [OPTIONS] [[+LINE,COLUMN] FILE]...
            AUTHORS
                Ilia Vaprol - Adaptation for Embox
        ''')
    module nano {
        source &quot;^BUILD/extbld/^MOD_PATH/install/nano.o&quot;

        @NoRuntime depends embox.compat.posix.regex

        depends embox.compat.posix.LibCurses
    }

</code></pre>
<p>Отличием описание данного модуля от описания обычного приложения являются два аспекта:</p>
<ul>
<li>Наличие аннотации @Build позволяющего задать некоторые детали процесса сборки модуля</li>
<li>В качестве файла исходного кода используется объектный файл</li>
</ul>
<a class="header" href="#Аннотация-build" id="Аннотация-build"><h2>Аннотация @Build</h2></a>
<p>Аннотация @Build позволяет задавать некоторые детали процесса сборки модуля к которому применена данная аннотация.</p>
<a class="header" href="#Стадия-сборки" id="Стадия-сборки"><h3>Стадия сборки</h3></a>
<p>Сборка Embox происходит в несколько стадий. Некоторые модули требуют предварительно подготовленного окружения. Например, если модулю требуются стандартная библиотека и собранные библиотеки из внешних репозиторий. Опция stage позволяет задать стадию сборки. Нулевая стадия включает в себя сборку стандартной библиотеки и ядра ОС. Начиная с первой стадии используется компилятор в котором в качестве библиотек используются собранные библиотеки с нулевой стадии. Вторая стадия используется для приложений которым требуется какое то собранное окружение.</p>
<a class="header" href="#Задание-внешнего-скрипта-сборки" id="Задание-внешнего-скрипта-сборки"><h3>Задание внешнего скрипта сборки</h3></a>
<p>С помощью аннотации @Build можно задавать свои правила для сборки. В том числе можно указать, часто используемый Makefile который позволяет задавать три цели (configure, build, install) (по аналогии с configure, make, make install). Для использования в качестве опции к аннотации нужно использовать</p>
<pre><code>    script=&quot;$(EXTERNAL_MAKE)&quot;
</code></pre>
<p>При использовании данного скрипта происходит выполнение makefile находящегося в данной директории.</p>
<p>Для того чтобы использовать разработанные скрипты упрощающие включение стороннего приложение можно использовать скрипт EXTBLD_LIB. Для этого необходимо включить эту библиотеку в makefile</p>
<pre><code>    ...
    include $(EXTBLD_LIB)
    ...
</code></pre>
<p>При подключении происходит скачивание архива, проверка контрольной суммы md5, накладывание патчей и затем выполнение целей</p>
<pre><code>    $(CONFIGURE) :
    ...
    $(BUILD) :
    ...
    $(INSTALL) :
    ...
</code></pre>
<p>для использования данного скрипта необходимо задать несколько переменных:</p>
<ul>
<li>PKG_SOURCES - название пакета</li>
<li>PKG_VER - версия пакета</li>
<li>PKG_SOURCES - url для скачивания</li>
<li>PKG_MD5 - контрольная сумма md5</li>
<li>PKG_PATCHES - список файлов с патчами для наложения на оригинальные исходники</li>
</ul>
<pre><code>    PKG_NAME := nano
    PKG_VER  := 2.2.6

    PKG_SOURCES := http://www.nano-editor.org/dist/v2.2/$(PKG_NAME)-$(PKG_VER).tar.gz
    PKG_MD5     := 03233ae480689a008eb98feb1b599807

    PKG_PATCHES := pkg_patch.txt

    include $(EXTBLD_LIB)

    $(CONFIGURE) :
    ...
</code></pre>
<p>цель $(CONFIGURE), должна перейти с директорию с распакованными и пропатчеными исходниками и затем вызвать configure с требуемыми параметрами:</p>
<pre><code>    $(CONFIGURE) :
        export EMBOX_GCC_LINK=full; \
        cd $(PKG_SOURCE_DIR) &amp;&amp; ( \
            ./configure --host=$(AUTOCONF_TARGET_TRIPLET) \
                --target=$(AUTOCONF_TARGET_TRIPLET) \
                --enable-tiny \
                --disable-shared \
                --disable-static \
                --disable-largefile \
                --disable-rpath \
                --disable-nls \
                --disable-extra \
                --disable-browser \
                --disable-help \
                --disable-justify \
                --disable-mouse \
                --disable-operatingdir \
                --disable-speller \
                --disable-tabcomp \
                --disable-wrapping \
                --disable-wrapping-as-root \
                --disable-color \
                --disable-multibuffer \
                --disable-nanorc \
                --disable-glibtest \
                CC=$(EMBOX_GCC) \
        )
        touch $@
</code></pre>
<p>цель $(BUILD) должна перейти в папку с исходниками и вызвать make если требуется передать дополнительные флаги.</p>
<pre><code>    $(BUILD) :
        cd $(PKG_SOURCE_DIR) &amp;&amp; ( \
            $(MAKE) MAKEFLAGS='$(EMBOX_IMPORTED_MAKEFLAGS)'; \
        )
        touch $@
</code></pre>
<p>цель  $(INSTALL), должна скопировать результаты сборки в папку для дальнейшей обработки в составе Embox (линковка в конечном образе или использование заголовочных файлов)</p>
<pre><code>    $(INSTALL) :
        cp $(PKG_SOURCE_DIR)/src/nano $(PKG_INSTALL_DIR)/nano.o
        touch $@
</code></pre>
<a class="header" href="#Включение-объектных-файлов" id="Включение-объектных-файлов"><h2>Включение объектных файлов</h2></a>
<p>В конечный образ Embox включаются только те файлы которые указаны в описании модуля, а не все файлы которые получились в процессе сборки стороннего проекта.
Таким образом объектный файл представляющий из себя приложение nano и скопированный в цели $(INSTALL) описанного выше Makefile не будет использоваться, если это не описано в модуле с помощью ключевого слова source:</p>
<pre><code>    ...
    module nano {
        source &quot;^BUILD/extbld/^MOD_PATH/install/nano.o&quot;
        ...
    }

</code></pre>
<p>В окончательный образ Embox включается бинарный код команды nano и если требуется, линкуется с конечным образом</p>
<a class="header" href="#Драйвера" id="Драйвера"><h1>Драйвера</h1></a>
<p>раздел в разработке</p>
<a class="header" href="#Описание-структуры-драйверов" id="Описание-структуры-драйверов"><h2>Описание структуры драйверов</h2></a>
<p>раздел в разработке</p>
<a class="header" href="#Типы-драйверов" id="Типы-драйверов"><h2>Типы драйверов</h2></a>
<p>раздел в разработке</p>
<a class="header" href="#Диагностический-интерфейс" id="Диагностический-интерфейс"><h3>Диагностический интерфейс</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#Контроллеры-прерываний" id="Контроллеры-прерываний"><h3>Контроллеры прерываний</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#Таймеры" id="Таймеры"><h3>Таймеры</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#Последовательные-порты-ttys" id="Последовательные-порты-ttys"><h3>Последовательные порты (ttys)</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#pci" id="pci"><h3>PCI</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#ethernet-карты" id="ethernet-карты"><h3>Ethernet карты</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#Графические-карты-framebuffer" id="Графические-карты-framebuffer"><h3>Графические карты (framebuffer)</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#devfs" id="devfs"><h2>devfs</h2></a>
<p>раздел в разработке</p>
<a class="header" href="#Блочные-устройста" id="Блочные-устройста"><h3>Блочные устройста</h3></a>
<p>раздел в разработке</p>
<a class="header" href="#Символьные-устройства" id="Символьные-устройства"><h3>Символьные устройства</h3></a>
<p>раздел в разработке</p>
<ul>
<li><a href="ru/platform/embox_supported_platforms_arm_ru.html">ARM</a></li>
<li><a href="ru/platform/embox_supported_platforms_qemu_ru.html">QEMU</a></li>
<li><a href="ru/platform/embox_supported_platforms_ru.html">RU</a></li>
<li><a href="ru/platform/embox_supported_platforms_x86_ru.html">x86</a></li>
</ul>
<a class="header" href="#arm-архитектура" id="arm-архитектура"><h2>ARM архитектура</h2></a>
<p>Embox поддерживает большинство ARM подархитектур: ARM7, ARM9, ARM-Cortex-M, ARM-Cortex-A. для работы со всеми платформами необходимо установить компилятор arm-none-eabi-gcc, как описано в разделе &quot;установка кросс-компилятора&quot;.</p>
<p>Embox поддерживает несколько популярных аппаратных платформ на базе процессоров с ARM архитектурой:</p>
<ul>
<li>STM32 MCU Eval Tools</li>
<li>Raspberry Pi</li>
<li>BeagleBoard</li>
</ul>
<a class="header" href="#Поддержка-эмулятора-qemu" id="Поддержка-эмулятора-qemu"><h2>Поддержка эмулятора QEMU</h2></a>
<p>Embox поддерживает запуск на QEMU со следующими архитектурами:</p>
<ul>
<li>qemu-system-i386</li>
<li>qemu-system-arm</li>
<li>qemu-system-mips</li>
<li>qemu-system-ppc</li>
<li>qemu-system-microblaze</li>
<li>qemu-system-sparc</li>
</ul>
<p>Для каждой архитектуры необходимо установить соответствующий кросс-компилятор</p>
<p>Для каждой из поддерживаемых архитектур необходимо сконфигурировать Embox</p>
<pre><code>        $ make confload-&lt;ARCH&gt;/qemu
</code></pre>
<p>где <ARCH>: x86, arm, mips, ppc, microblaze, sparc</p>
<p>Для запуска можно выполнить скрипт:</p>
<pre><code>        $ ./scripts/qemu/auto_qemu
</code></pre>
<p>данный скрипт разберет содержимое конфигурационных файлов в папке conf/ и запустит qemu c нужными параметрами.</p>
<a class="header" href="#Поддерживаемые-платформы" id="Поддерживаемые-платформы"><h1>Поддерживаемые платформы</h1></a>
<p>Embox поддерживает несколько процессорных архитектур: ARM, x86, SPARC, DLX (Microblaze), MIPS, PPC (PowerPC), E2k (Elbrus). Для каждой архитектуры может быть поддержано несколько аппаратных платформ, как реальных плат, так и виртуальных. Для каждой архитектуры необходимо установить кросс-компилятор, как описано в разделе &quot;Установка кросс-компилятора&quot; и отладчик gdb, который обычно входит в состав кросс-компилятора при установке. Процесс запуска и отладки для различных платформ может отличаться.</p>
<a class="header" href="#x86-архитектура" id="x86-архитектура"><h2>x86 архитектура</h2></a>
<p>Embox поддерживает 32 разрядную архитектуры x86 и драйвера для различного рода периферии. Для работы на Linux в качестве кросс-компилятора используется gcc.</p>
<p>Embox поддерживает:</p>
<ul>
<li>qemu-system-i386</li>
<li>Загрузка через GRUB</li>
<li>BifferBoard</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
